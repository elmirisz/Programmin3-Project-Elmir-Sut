package elmir.sut.project;

/**
 * Handles the convolution operation with a filter
 */
public class Convolution {
	
/** 
 * Notice : I will use only grey scale photo, colors will be converted to white intensity number
 * 
 */

    /**
     * Takes an image (grey-levels) and a kernel and a position,
     * applies the convolution at that position and returns the
     * new pixel value.
     *
     * @param input        The 2D double array representing the image.
     * @param x            The x coordinate for the position of the convolution.
     * @param y            The y coordinate for the position of the convolution.
     * @param k            The 2D array representing the kernel.
     * @param kernelWidth  The width of the kernel.
     * @param kernelHeight The height of the kernel.
     * @return The new pixel value after the convolution.
     */
	
	
    public static double singlePixelConvolution(double[][] input, //part of the picture we select
                                                int x, int y, //to get current part of the picture to be convoluted
                                                double[][] k, //actual kernel matrix
                                                int kernelWidth, //kernel size used in loop
                                                int kernelHeight) {
        double output = 0; //accumulator
        for (int i = 0; i < kernelWidth; ++i) {
            for (int j = 0; j < kernelHeight; ++j) {
                output = output + (input[x + i][y + j] * k[i][j]); //we traverse through kernel and multiply
            }
        }
        return output;
    }

    /** 
     * input[x][y]  position of original pixel 
     * input[x + i][y + j] taking value of neighboring  pixels
     *  * k[i][j] multyplying with kernel position value
     * 
     * return output returns sum of all these multiplications 
     * 
     * */
    
    

    
    /**
     * Takes a 2D array of grey-levels and a kernel and applies the convolution
     * over the area of the image specified by width and height.
     *
     * @param input        the 2D double array representing the image
     * @param width        the width of the image
     * @param height       the height of the image
     * @param kernel       the 2D array representing the kernel
     * @param kernelWidth  the width of the kernel
     * @param kernelHeight the height of the kernel
     * @return the 2D array representing the new image
     */
    public static double[][] convolution2D(double[][] input,
                                           int width, int height,
                                           double[][] kernel,
                                           int kernelWidth,
                                           int kernelHeight) {
    	
        int smallWidth = width - kernelWidth + 1;//this is used so we do not come till edge of picture without sufficent pixels
        int smallHeight = height - kernelHeight + 1; //so we convolute last kernel sized matrix of the picture
        
        double[][] output = new double[width][height];//new matrix image accumulator
        
        for (int i = 0; i < width; ++i) {  //for each cell we will set value to be zero 0
            for (int j = 0; j < height; ++j) {
                output[i][j] = 0;
            }
        }
        //here we need to fill in each cell
        for (int i = 1; i < smallWidth; ++i) { //filling in the values starting from beginning
            for (int j = 1; j < smallHeight; ++j) {
                output[i][j] = singlePixelConvolution(input, i, j, kernel,
                        kernelWidth, kernelHeight); //calculating every single pixel and saving it
                
            }
        }
        System.out.println("Size of output: " + output.length +  "; "+output[0].length);
        
        return output;
    }

    
    /**
     * Takes a 2D array of grey-levels and a kernel, applies the convolution
     * over the area of the image specified by width and height and returns
     * a part of the final image.
     *
     * @param input        the 2D double array representing the image
     * @param width        the width of the image
     * @param height       the height of the image
     * @param kernel       the 2D array representing the kernel
     * @param kernelWidth  the width of the kernel
     * @param kernelHeight the height of the kernel
     * @return the 2D array representing the new image
     */
//    public static double[][] convolutionFinal(double[][] input,
//                                                 int width, int height,
//                                                 double[][] kernel,
//                                                 int kernelWidth,
//                                                 int kernelHeight) {
//        int smallWidth = width - kernelWidth + 1; //when we come to an edge of the picture
//        int smallHeight = height - kernelHeight + 1; //when we come to an edge of the picture
//        int top = kernelHeight / 2; //size is 1
//        int left = kernelWidth / 2; //size is 1
//        
//
//        double[][] small = convolution2D(input, width, height,
//                kernel, kernelWidth, kernelHeight);
//        
//        //instantiating large with all zero values
//        //it will extra pixels depending on kernel size in order to avoid edges to be black completely 
//        double large[][] = new double[width][height];
//        for (int j = 0; j < height; ++j) {
//            for (int i = 0; i < width; ++i) {
//                large[i][j] = 0;
//            }
//        }
//        
//        //understand why we have one iteration plus
//        //adds extra two pixels to work with
//        
//        
//        for (int j = 0; j < smallHeight; ++j) {
//            for (int i = 0; i < smallWidth; ++i) {
//                large[i + left][j + top] = small[i][j];
//                //first pixel row value untouched and first column large[0][*]... larte [*][0]
//                
//            }
//        }
//        System.out.println("Size of small matrix: " + small.length +  "; "+small[0].length);
//        
//        System.out.println("Size of large matrix: " + large.length +  "; "+large[0].length);
//        
//        return large;
//    }


   
}
    